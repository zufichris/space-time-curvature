<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spacetime Curvature Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000011; /* Moved background color here for consistency */
    }
    #container {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <!-- Importing Three.js and OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // --- Basic Setup ---
    const container = document.getElementById("container");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000011);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, -20, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // --- Lighting ---
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1).normalize();
    scene.add(directionalLight);

    const ambientLight = new THREE.AmbientLight(0x111111);
    scene.add(ambientLight);

    // --- Orbit Controls ---
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.update();

    // --- Stars ---
    const stars = [];
    const numStars = 500;
    const starGeometry = new THREE.SphereGeometry(0.02, 8, 8);
    const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    for (let i = 0; i < numStars; i++) {
      const star = new THREE.Mesh(starGeometry, starMaterial);
      star.position.set(
        (Math.random() - 0.5) * 100,
        (Math.random() - 0.5) * 100,
        (Math.random() - 0.5) * 100
      );
      scene.add(star);
      stars.push(star);
    }

    // --- Spacetime Grid ---
    const gridSize = 20;
    const gridSegments = 150;
    const gridGeometry = new THREE.PlaneGeometry(gridSize, gridSize, gridSegments, gridSegments);
    const gridMaterial = new THREE.MeshPhongMaterial({
      color: 0x333333,
      wireframe: true,
      transparent: true,
      opacity: 0.8
    });
    const gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
    scene.add(gridMesh);

    // --- Sphere (Mass) ---
    const sphereRadius = 1;
    const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 64, 64);
    const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffa500 });
    const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphereMesh.position.set(0, 0, -4);
    scene.add(sphereMesh);

    // --- Particles ---
    const particles = [];
    const numParticles = 200;
    const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
    const particleMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
    for (let i = 0; i < numParticles; i++) {
      const particle = new THREE.Mesh(particleGeometry, particleMaterial);
      particle.position.set(
        (Math.random() - 0.5) * gridSize,
        (Math.random() - 0.5) * gridSize,
        0
      );
      // Store velocity in userData for clarity
      particle.userData = {
        vx: (Math.random() - 0.5) * 0.2,
        vy: (Math.random() - 0.5) * 0.2
      };
      scene.add(particle);
      particles.push(particle);
    }

    // --- Animation ---
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const deltaTime = clock.getDelta();
      const elapsedTime = clock.getElapsedTime();

      // Sphere Orbit Motion
      const orbitRadius = 7;
      sphereMesh.position.x = orbitRadius * Math.cos(elapsedTime * 0.7);
      sphereMesh.position.y = orbitRadius * Math.sin(elapsedTime * 0.7);
      sphereMesh.rotation.y += 0.05;

      // Grid Deformation (simulate gravitational curvature)
      const positions = gridGeometry.attributes.position;
      const sphereX = sphereMesh.position.x;
      const sphereY = sphereMesh.position.y;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const dx = x - sphereX;
        const dy = y - sphereY;
        const r2 = dx * dx + dy * dy + 1;
        // Gravitational deformation effect: deeper well near the sphere
        const z = -7 / Math.sqrt(r2);
        positions.setZ(i, z);
      }
      positions.needsUpdate = true;

      // Particle Movement and Sphere Influence
      particles.forEach((particle) => {
        particle.position.x += particle.userData.vx;
        particle.position.y += particle.userData.vy;

        // Calculate distance to the sphere
        const dx = particle.position.x - sphereX;
        const dy = particle.position.y - sphereY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // If within influence radius, adjust velocity to simulate gravitational pull
        if (distance < 3) {
          const force = 0.5 / (distance + 0.1);
          particle.userData.vx -= dx * force * deltaTime;
          particle.userData.vy -= dy * force * deltaTime;
        } else {
          // Apply slight deceleration when not near the sphere
          particle.userData.vx *= 0.99;
          particle.userData.vy *= 0.99;
        }

        // Simple boundary collision for particles
        if (particle.position.x > gridSize / 2 || particle.position.x < -gridSize / 2) {
          particle.userData.vx *= -1;
        }
        if (particle.position.y > gridSize / 2 || particle.position.y < -gridSize / 2) {
          particle.userData.vy *= -1;
        }
      });

      // Move Stars to Create a Parallax Effect
      stars.forEach((star) => {
        star.position.z += 0.1;
        if (star.position.z > 50) {
          star.position.z = -50;
          star.position.x = (Math.random() - 0.5) * 100;
          star.position.y = (Math.random() - 0.5) * 100;
        }
      });

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // --- Responsive Resize ---
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
